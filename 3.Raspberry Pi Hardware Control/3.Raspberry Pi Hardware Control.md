# 3.Raspberry Pi Hardware Control

<span style="color: rgb(255, 76, 65);">Note: need to turn off the programme of boot-up, then follow the below
instructions</span>

Open the terminal and input sudo nano /etc/rc.local then press Enter

![](/media/3db288837d9f1fa26f3fefed5db2eaad.png)

Add \# before enabling the scripts, as shown below;

![](/media/fd09271425f350ce513d497bd8b0c079.png)

Press **Ctrl + o** to save, then press Enter and **Ctrl + X** to exit editing

## **Raspberry Pi Control Project**

### Expansion Board

When programming GPIO pins, there are three different ways to refer to
them: BCM GPIO number, physical number and WiringPi GPIO number.
Generally the WiringPi GPIO number is for the C language.The BCM GPIO
number and physical numbers can be applied to Python.

Our tutorial is written in Python, so the BCM GPIO number will be used,
and the silkscreen on the expansion board is identified by the BCM GPIO
number.

![](/media/e259fbf918cba2ae9c56d93675d40717.jpeg)

### 1.Passive Buzzer
    
    Passive buzzer relies on piezoelectric effect to produce sound which
    is very clear and pleasant, suitable for electronic music box.

<table>
<tbody>
<tr class="odd">
<td>BCM pin：GPIO 16</td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS0223-Keyestudio-Smart-Car-Kit-for-Raspberry-Pi/master/media/1c7058277b5cd5fd84dc9afa6c054183.png" style="width:3.02986in;height:2.36319in" /></td>
</tr>
</tbody>
</table>

 Code 1

<table>
<tbody>
<tr class="odd">
<td><p># -*- coding: utf-8 -*-</p>
<p>import time</p>
<p>import RPi.GPIO as GPIO</p>
<p>buzPin = 16</p>
<p>i1 = 0</p>
<p>i2 = 0</p>
<p>GPIO.setmode(GPIO.BCM) # use BCM numbers</p>
<p>GPIO.setup(buzPin, GPIO.OUT) # set pin OUTPUT mode</p>
<p>try:</p>
<p>while 1: #loop</p>
<p>while(i1&lt;50):</p>
<p>GPIO.output(buzPin,GPIO.HIGH)</p>
<p>time.sleep(0.001) #wait for 1 ms</p>
<p>GPIO.output(buzPin,GPIO.LOW)</p>
<p>time.sleep(0.001)</p>
<p>i1 = i1 + 1</p>
<p>time.sleep(0.3)</p>
<p>while(i2&lt;50):</p>
<p>GPIO.output(buzPin,GPIO.HIGH)</p>
<p>time.sleep(0.001) #wait for 1 ms</p>
<p>GPIO.output(buzPin,GPIO.LOW)</p>
<p>time.sleep(0.001)</p>
<p>i2 = i2 + 1</p>
<p>time.sleep(1)</p>
<p>i1 = 0</p>
<p>i2 = 0</p>
<p>except KeyboardInterrupt:</p>
<p>pass</p>
<p>GPIO.cleanup() #release all GPIO</p></td>
</tr>
</tbody>
</table>

2.   Run code 1 and test result
    
    cd /home/pi/RaspberryPi-Car/basic\_project
    
    sudo python3 bp1\_1buzzer.py
    
    ![](/media/c36ac6030216b419ec088b179e7bd7e7.png)
    
    After running test code, the buzzer will emit “tick,tick” sound。
    
    Press "Ctrl + C" to exit code running

3.   Code 2
    
    This example code uses GPIO.PWM to make the buzzer emit sounds with
    different frequency.

<table>
<tbody>
<tr class="odd">
<td><p># -*- coding: utf-8 -*-</p>
<p>import RPi.GPIO as GPIO</p>
<p>import time</p>
<p>Buzzer = 16 # set the Pin</p>
<p># Happy birthday</p>
<p>Do = 262</p>
<p>Re = 294</p>
<p>Mi = 330</p>
<p>Fa = 349</p>
<p>Sol = 392</p>
<p>La = 440</p>
<p>Si = 494</p>
<p>Do_h = 523</p>
<p>Re_h = 587</p>
<p>Mi_h = 659</p>
<p>Fa_h = 698</p>
<p>Sol_h = 784</p>
<p>La_h = 880</p>
<p>Si_h = 988</p>
<p># The tune</p>
<p>song_1 = [</p>
<p>Sol,Sol,La,Sol,Do_h,Si,</p>
<p>Sol,Sol,La,Sol,Re_h,Do_h,</p>
<p>Sol,Sol,Sol_h,Mi_h,Do_h,Si,La,</p>
<p>Fa_h,Fa_h,Mi_h,Do_h,Re_h,Do_h</p>
<p>]</p>
<p># delay</p>
<p>beat_1 = [</p>
<p>0.5,0.5,1,1,1,1+1,</p>
<p>0.5,0.5,1,1,1,1+1,</p>
<p>0.5,0.5,1,1,1,1,1,</p>
<p>0.5,0.5,1,1,1,1+1,</p>
<p>]</p>
<p>def setup():</p>
<p>GPIO.setmode(GPIO.BCM) # Numbers GPIOs by physical location</p>
<p>GPIO.setup(Buzzer, GPIO.OUT) # Set pins' mode is output</p>
<p>global Buzz # Assign a global variable to replace GPIO.PWM</p>
<p>Buzz = GPIO.PWM(Buzzer, 440) # 440 is initial frequency.</p>
<p>Buzz.start(50) # Start Buzzer pin with 50% duty ration</p>
<p>def loop():</p>
<p>while True:</p>
<p>print('\n Playing song 3...')</p>
<p>for i in range(0, len(song_1)): # Play song 1</p>
<p>Buzz.ChangeFrequency(song_1[i]) # Change the frequency along the song note</p>
<p>time.sleep(beat_1[i] * 0.5) # delay a note for beat * 0.5s</p>
<p>def destory():</p>
<p>Buzz.stop() # Stop the buzzer</p>
<p>GPIO.output(Buzzer, 1) # Set Buzzer pin to High</p>
<p>GPIO.cleanup() # Release resource</p>
<p>if __name__ == '__main__': # Program start from here</p>
<p>setup()</p>
<p>try:</p>
<p>loop()</p>
<p>except KeyboardInterrupt: # When 'Ctrl+C' is pressed, the child program destroy() will be executed.</p>
<p>destory()</p></td>
</tr>
</tbody>
</table>

4.   Run code 2
    
    cd /home/pi/RaspberryPi-Car/basic\_project
    
    sudo python3 bp1\_2buzzer\_pwm.py
    
    After running test code, the buzzer will play a birthday song.
    
    Press "Ctrl + C" to exit code running

### 2.Line Tracking Sensor

The detection element of the tracking sensor is composed of an infrared
light-emitting tube and an infrared receiving tube.

It mainly depends on whether the infrared receiving tube can receive the
infrared rays emitted by the transmitting tube.

<table>
<tbody>
<tr class="odd">
<td>Pins of three-channel line tracking sensor： L : GPIO 19 M : GPIO 18 R : GPIO 17</td>
</tr>
</tbody>
</table>

 Code

<table>
<tbody>
<tr class="odd">
<td><p>import RPi.GPIO as GPIO</p>
<p>from time import sleep</p>
<p>#tracking pin</p>
<p>trackingPin1 = 17</p>
<p>trackingPin2 = 18</p>
<p>trackingPin3 = 19</p>
<p>GPIO.setmode(GPIO.BCM) # use BCM numbers</p>
<p>GPIO.setup(trackingPin1,GPIO.IN) # set trackingPin INPUT mode</p>
<p>GPIO.setup(trackingPin2,GPIO.IN)</p>
<p>GPIO.setup(trackingPin3,GPIO.IN)</p>
<p>while True:</p>
<p>val1 = GPIO.input(trackingPin1) # read the value</p>
<p>val2 = GPIO.input(trackingPin2)</p>
<p>val3 = GPIO.input(trackingPin3)</p>
<p>print("tracking1 = ", val1, "tracking2 = ", val2, "tracking3 = ", val3)</p>
<p>sleep(0.1)</p>
<p>GPIO.cleanup() # Release all GPIO</p></td>
</tr>
</tbody>
</table>

2.   Run code and test result
    
    cd /home/pi/RaspberryPi-Car/basic\_project
    
    sudo python3 bp2\_tracking.py

If the car is placed on the table, the IR receiving tube will receive
the IR rays and the value will be 0; as shown below;

![](/media/dc6bfd7b9746575649d515d04c53a80e.png)

### 3.Ultrasonic Sensor

Ultrasonic sensor is a very affordable distance sensor, mainly used in
various robot projects to avoid objects.

**The principle of ultrasonic sensor**

As the above picture shown, it is like two eyes. One is transmitting
end, the other is receiving end.

The ultrasonic module will emit the ultrasonic waves after triggering a
signal. When the ultrasonic waves encounter the object and are reflected
back, the module outputs an echo signal, so it can determine the
distance of the object from the time difference between the trigger
signal and echo signal.

The t is the time that emitting signal meets obstacle and returns. And
the propagation speed of sound in the air is about 343m/s, and distance
= speed \* time. However, the ultrasonic wave emits and comes back,
which is 2 times of distance. Therefore, it needs to be divided by 2,
the distance measured by ultrasonic wave = (speed \* time)/2

1.  Use method and timing chart of ultrasonic module:

2.  Setting the delay time of Trig pin of SR04 to 10μs at least, which
    can trigger it to detect distance.

3.  After triggering, the module will automatically send eight 40KHz
    ultrasonic pulses and detect whether there is a signal return. This
    step will be completed automatically by the module.

4.  If the signal returns, the Echo pin will output a high level, and
    the duration of the high level is the time from the transmission of
    the ultrasonic wave to the return.

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS0223-Keyestudio-Smart-Car-Kit-for-Raspberry-Pi/master/media/ba43be6007d9fe3aab0bb609868af640.png" style="width:6.51181in;height:1.95556in" /></td>
</tr>
</tbody>
</table>

<table>
<tbody>
<tr class="odd">
<td>Pins of ultrasonic sensor： Trig : GPIO 14　　　　Echo : GPIO 4</td>
</tr>
</tbody>
</table>

 Code

<table>
<tbody>
<tr class="odd">
<td><p>import RPi.GPIO as GPIO</p>
<p>import time</p>
<p>GPIO.setmode(GPIO.BCM)</p>
<p>#define GPIO pin</p>
<p>GPIO_TRIGGER = 14</p>
<p>GPIO_ECHO = 4</p>
<p>#set GPIO mode (IN / OUT)</p>
<p>GPIO.setup(GPIO_TRIGGER, GPIO.OUT)</p>
<p>GPIO.setup(GPIO_ECHO, GPIO.IN)</p>
<p>def distance():</p>
<p># 10us is the trigger signal</p>
<p>GPIO.output(GPIO_TRIGGER, True)</p>
<p>time.sleep(0.00001) #10us</p>
<p>GPIO.output(GPIO_TRIGGER, False)</p>
<p>start_time = time.time() # Log the time the program runs to this point</p>
<p>stop_time = time.time() # Log the time the program runs to this point</p>
<p>while GPIO.input(GPIO_ECHO) == 0: #Indicates that the ultrasonic wave has been emitted</p>
<p>start_time = time.time() #Record launch time</p>
<p>while GPIO.input(GPIO_ECHO) == 1: #Indicates that the returned ultrasound has been received</p>
<p>stop_time = time.time() #Record receiving time</p>
<p>time_elapsed = stop_time - start_time #Time difference from transmit to receive</p>
<p>distance = (time_elapsed * 34000) / 2 #Calculate the distance</p>
<p>return distance #Return to calculated distance</p>
<p>if __name__ == '__main__': #Program entry</p>
<p>try:</p>
<p>while True:</p>
<p>dist = distance() #</p>
<p>print("Measured Distance =  cm".format(dist)) #,Keep two decimal places</p>
<p>time.sleep(0.1)</p>
<p># Reset by pressing CTRL + C</p>
<p>except KeyboardInterrupt:</p>
<p>print("Measurement stopped by User")</p>
<p>GPIO.cleanup()</p></td>
</tr>
</tbody>
</table>

 3.2 Run code and test result

cd /home/pi/RaspberryPi-Car/basic\_project

sudo python3 bp3\_ultrasonic.py

After running test code, then the detected distance value will be
displayed on the terminal.

![](/media/a1c592762be20fba46dae727904195b2.png)

### 4.Servo Control

Servo motor is a position control rotary actuator. It mainly consists of
a housing, a circuit board, a core-less motor, a gear and a position
sensor. In general, servo has three lines in brown, red and orange. The
brown wire is grounded, the red one is a positive pole line and the
orange one is a signal line.

When the motor speed is constant, the potentiometer is driven to rotate
through the cascade reduction gear, which leads that the voltage
difference is 0, and the motor stops rotating. Generally, the angle
range of servo rotation is 0° --180 °

The rotation angle of servo motor is controlled by regulating the duty
cycle of PWM (Pulse-Width Modulation) signal. The standard cycle of PWM
signal is 20ms (50Hz). Theoretically, the width is distributed between
1ms-2ms, but in fact, it's between 0.5ms-2.5ms. The width corresponds
the rotation angle from 0° to 180°. But note that for different brand
motors, the same signal may have different rotation angles.

![](/media/9c287c5ca4f5792f52b8c72d0d2a5448.png)

<table>
<tbody>
<tr class="odd">
<td><p>Pins of servo：</p>
<p>Servo for ultrasonic sensor： GPIO 5 Base servo： GPIO 7 Servo for camera：GPIO 6</p></td>
</tr>
</tbody>
</table>

 4.1 Code 1

We first control the servo on the pan tilt to rotate

<table>
<tbody>
<tr class="odd">
<td><p>import RPi.GPIO as GPIO</p>
<p>import time</p>
<p>servoPin1 = 5</p>
<p>GPIO.setmode(GPIO.BCM)</p>
<p>GPIO.setwarnings(False)</p>
<p>def init():</p>
<p>GPIO.setup(servoPin1, GPIO.OUT)</p>
<p>def servoPulse(servoPin, myangle):</p>
<p>pulsewidth = (myangle*11) + 500 # The pulse width</p>
<p>GPIO.output(servoPin,GPIO.HIGH)</p>
<p>time.sleep(pulsewidth/1000000.0)</p>
<p>GPIO.output(servoPin,GPIO.LOW)</p>
<p>time.sleep(20.0/1000 - pulsewidth/1000000.0) # The cycle of 20 ms</p>
<p>try:</p>
<p>init()</p>
<p>while True:</p>
<p>for i in range(0,180):</p>
<p>servoPulse(servoPin1, i)</p>
<p>for i in range(0,180):</p>
<p>i = 180 - i</p>
<p>servoPulse(servoPin1, i)</p>
<p>except KeyboardInterrupt:</p>
<p>pass</p></td>
</tr>
</tbody>
</table>

 4.2 Run code and test result

cd /home/pi/RaspberryPi-Car/basic\_project

sudo python3 bp4\_servo\_test.py

After running code, the servo for ultrasonic sensor rotates

 4.3 Code2

The servo controlling the pan tilt of the camera rotates

<table>
<tbody>
<tr class="odd">
<td><p>import RPi.GPIO as GPIO</p>
<p>import time</p>
<p>servoPin2 = 7</p>
<p>servoPin3 = 6</p>
<p>GPIO.setmode(GPIO.BCM)</p>
<p>GPIO.setwarnings(False)</p>
<p>def init():</p>
<p>GPIO.setup(servoPin2, GPIO.OUT)</p>
<p>GPIO.setup(servoPin3, GPIO.OUT)</p>
<p>def servoPulse(servoPin, myangle):</p>
<p>pulsewidth = (myangle*11) + 500 # The pulse width</p>
<p>GPIO.output(servoPin,GPIO.HIGH)</p>
<p>time.sleep(pulsewidth/1000000.0)</p>
<p>GPIO.output(servoPin,GPIO.LOW)</p>
<p>time.sleep(20.0/1000 - pulsewidth/1000000.0) # The cycle of 20 ms</p>
<p>try:</p>
<p>init()</p>
<p>while True:</p>
<p>for i in range(0,180):</p>
<p>servoPulse(servoPin2, i)</p>
<p>for i in range(0,180):</p>
<p>servoPulse(servoPin3, i)</p>
<p>for i in range(0,180):</p>
<p>i = 180 - i</p>
<p>servoPulse(servoPin2, i)</p>
<p>for i in range(0,180):</p>
<p>i = 180 - i</p>
<p>servoPulse(servoPin3, i)</p>
<p>for j in range(0, 50):</p>
<p>servoPulse(servoPin2, 90)</p>
<p>for j in range(0, 50):</p>
<p>servoPulse(servoPin3, 90)</p>
<p>time.sleep(2)</p>
<p>except KeyboardInterrupt:</p>
<p>pass</p>
<p>GPIO.cleanup()</p></td>
</tr>
</tbody>
</table>

 4.4 Run code and test result

cd /home/pi/RaspberryPi-Car/basic\_project

sudo python3 bp4\_2servo.py

After running the code, the pan tilt of the camera rotates.

### 5.LED Panel

The data of the microprocessor (arduino) communicates with the AiP1640
through the two-wire bus interface.

 5.1 8\*16 Dot Matrix Display

![](/media/edf6c77d05904eebbaa89d557e9e9c1a.png)

 5.2 Interface Description and Communication Protocol:

The communication protocol diagram is shown below:

(SCLK) is SCL, (DIN) is SDA:

![](/media/ea2bab37f23c09453c680590b84653d6.png)

①The starting condition for data input: SCL is high level and SDA
changes from high to low.

②For data command setting, there are methods as shown in the figure
below

In our sample program, select the way to **add 1 to the address
automatically**, the binary value is 0100 0000 and the corresponding
hexadecimal value is 0x40

<table>
<tbody>
<tr class="odd">
<td><table>
<tbody>
<tr class="odd">
<td>add 1 to the address automatically</td>
</tr>
<tr class="even">
<td>Fixed address</td>
</tr>
<tr class="odd">
<td>Universal mode</td>
</tr>
<tr class="even">
<td>Test mode</td>
</tr>
</tbody>
</table>
<p><img src="https://raw.githubusercontent.com/keyestudio/KS0223-Keyestudio-Smart-Car-Kit-for-Raspberry-Pi/master/media/7e326d7edc877ea2509cbf8649f82d99.png" style="width:5.60972in;height:1.94306in" /></p></td>
</tr>
</tbody>
</table>

③For address command setting, the address can be selected as shown
below.

The first 00H is selected in our sample program, and the binary number
1100 0000 corresponds to the hexadecimal 0xc0

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS0223-Keyestudio-Smart-Car-Kit-for-Raspberry-Pi/master/media/e6da87c9f6056f849c973edec5456f3e.png" style="width:4.53056in;height:3.70069in" /></td>
</tr>
</tbody>
</table>

④The requirement for data input is that SCL is high level when inputting
data, the signal on SDA must remain unchanged. Only when the clock
signal on SCL is low level, the signal on SDA can be altered. The data
input is low-order first, high-order is behind

⑤ The condition to end data transmission is that when SCL is low, SDA is
low, and when SCL is high, the SDA level also becomes high.

⑥ Display control, set different pulse width, the pulse width can be
selected as shown below

In the example, we choose pulse width 4/16, and the hexadecimal
corresponds to 1000 1010 is 0x8A

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS0223-Keyestudio-Smart-Car-Kit-for-Raspberry-Pi/master/media/ad238f413988f77bcf074a5642a5061d.png" style="width:6.6in;height:2.95556in" /></td>
</tr>
</tbody>
</table>

 5.3 Introduction for modulus tool

The online version of dot matrix modulus tool:

[http://dotmatrixtool.com/\#](http://dotmatrixtool.com/)

①Open the link to enter the following page.

![](/media/354693b5679a2615c62e99b7025d6355.png)

②The dot matrix is 8\*16 in this project. So set the height to 8, width
to 16, and select Big Endian; as shown below.

![](/media/3e3b3ec2fbd61d9c6957e429c8705b91.png)

③ Generate hexadecimal data from the pattern

As shown below, the left button of the mouse is for selection while the
right is for canceling. Thus you could use them to draw the pattern you
want, then click **Generate**, to yield the hexadecimal data needed.

![](/media/42c8495c551874f644c4fbfe5f7233fe.png)

<table>
<tbody>
<tr class="odd">
<td>BCM pin： SCL : GPIO 8 SDA : GPIO 9</td>
</tr>
</tbody>
</table>

 5.4 Code

<table>
<tbody>
<tr class="odd">
<td><p>import RPi.GPIO as GPIO</p>
<p>import time</p>
<p>SCLK = 8</p>
<p>DIO = 9</p>
<p># Display pattern data</p>
<p>smile = (0x00, 0x00, 0x38, 0x40, 0x40, 0x40, 0x3a, 0x02, 0x02, 0x3a, 0x40, 0x40, 0x40, 0x38, 0x00, 0x00)</p>
<p>matrix_forward = (0x00, 0x00, 0x00, 0x00, 0x12, 0x24, 0x48, 0x90, 0x90, 0x48, 0x24, 0x12, 0x00, 0x00, 0x00, 0x00)</p>
<p>matrix_back = (0x00, 0x00, 0x00, 0x00, 0x48, 0x24, 0x12, 0x09, 0x09, 0x12, 0x24, 0x48, 0x00, 0x00, 0x00, 0x00)</p>
<p>matrix_left = (0x00, 0x00, 0x00, 0x00, 0x18, 0x24, 0x42, 0x99, 0x24, 0x42, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00)</p>
<p>matrix_right = (0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x42, 0x24, 0x99, 0x42, 0x24, 0x18, 0x00, 0x00, 0x00, 0x00)</p>
<p>GPIO.setwarnings(False)</p>
<p>GPIO.setmode(GPIO.BCM)</p>
<p>GPIO.setup(SCLK,GPIO.OUT)</p>
<p>GPIO.setup(DIO,GPIO.OUT)</p>
<p>def nop():</p>
<p>time.sleep(0.00003)</p>
<p>def start():</p>
<p>GPIO.output(SCLK,0)</p>
<p>nop()</p>
<p>GPIO.output(SCLK,1)</p>
<p>nop()</p>
<p>GPIO.output(DIO,1)</p>
<p>nop()</p>
<p>GPIO.output(DIO,0)</p>
<p>nop()</p>
<p>def matrix_clear():</p>
<p>GPIO.output(SCLK,0)</p>
<p>nop()</p>
<p>GPIO.output(DIO,0)</p>
<p>nop()</p>
<p>GPIO.output(DIO,0)</p>
<p>nop()</p>
<p>def send_date(date):</p>
<p>for i in range(0,8):</p>
<p>GPIO.output(SCLK,0)</p>
<p>nop()</p>
<p>if date &amp; 0x01:</p>
<p>GPIO.output(DIO,1)</p>
<p>else:</p>
<p>GPIO.output(DIO,0)</p>
<p>nop()</p>
<p>GPIO.output(SCLK,1)</p>
<p>nop()</p>
<p>date &gt;&gt;= 1</p>
<p>GPIO.output(SCLK,0)</p>
<p>def end():</p>
<p>GPIO.output(SCLK,0)</p>
<p>nop()</p>
<p>GPIO.output(DIO,0)</p>
<p>nop()</p>
<p>GPIO.output(SCLK,1)</p>
<p>nop()</p>
<p>GPIO.output(DIO,1)</p>
<p>nop()</p>
<p>def matrix_display(matrix_value):</p>
<p>start()</p>
<p>send_date(0xc0)</p>
<p>for i in range(0,16):</p>
<p>send_date(matrix_value[i])</p>
<p>end()</p>
<p>start()</p>
<p>send_date(0x8A)</p>
<p>end()</p>
<p>try:</p>
<p>while True:</p>
<p>matrix_display(smile)</p>
<p>time.sleep(1)</p>
<p>matrix_display(matrix_back)</p>
<p>time.sleep(1)</p>
<p>matrix_display(matrix_forward)</p>
<p>time.sleep(1)</p>
<p>matrix_display(matrix_left)</p>
<p>time.sleep(1)</p>
<p>matrix_display(matrix_right)</p>
<p>time.sleep(1)</p>
<p>except KeyboardInterrupt:</p>
<p>GPIO.cleanup()</p></td>
</tr>
</tbody>
</table>

 5.5 Run code and test result

cd /home/pi/RaspberryPi-Car/basic\_project

sudo python3 bp5\_LED8X16\_TM1604.py

After running the code, the dot matrix shows a smile image and a
direction pattern.

### 6.OLED Display 

OLED display is the most commonly used for mobile phone. It features the
fine image quality, small size and high brightness. The size of our OLED
display is 0.96 inches, and the driving chip is SSD1306. It adopts IIC
communication, with a resolution of 128\*64.

For more information, please refer to:

<https://github.com/adafruit/Adafruit_CircuitPython_SSD1306>

 6.1 Code

<table>
<tbody>
<tr class="odd">
<td><p>import time</p>
<p>import Adafruit_GPIO.SPI as SPI</p>
<p>import Adafruit_SSD1306</p>
<p>from PIL import Image</p>
<p>from PIL import ImageDraw</p>
<p>from PIL import ImageFont</p>
<p>import subprocess</p>
<p># Raspberry Pi pin configuration:</p>
<p>RST = None # on the PiOLED this pin isnt used</p>
<p># Note the following are only used with SPI:</p>
<p>DC = 23</p>
<p>SPI_PORT = 0</p>
<p>SPI_DEVICE = 0</p>
<p># Beaglebone Black pin configuration:</p>
<p># 128x64 display with hardware I2C:</p>
<p>disp = Adafruit_SSD1306.SSD1306_128_64(rst=RST)</p>
<p># Initialize library.</p>
<p>disp.begin()</p>
<p># Clear display.</p>
<p>disp.clear()</p>
<p>disp.display()</p>
<p># Create blank image for drawing.</p>
<p># Make sure to create image with mode '1' for 1-bit color.</p>
<p>width = disp.width</p>
<p>height = disp.height</p>
<p>image = Image.new('1', (width, height))</p>
<p># Get drawing object to draw on image.</p>
<p>draw = ImageDraw.Draw(image)</p>
<p># Draw a black filled box to clear the image.</p>
<p>draw.rectangle((0,0,width,height), outline=0, fill=0)</p>
<p># Draw some shapes.</p>
<p># First define some constants to allow easy resizing of shapes.</p>
<p>padding = -2</p>
<p>top = padding</p>
<p>bottom = height-padding</p>
<p># Move left to right keeping track of the current x position for drawing shapes.</p>
<p>x = 0</p>
<p># Load default font.</p>
<p>font = ImageFont.load_default()</p>
<p># Alternatively load a TTF font. Make sure the .ttf font file is in the same directory as the python script!</p>
<p># Some other nice fonts to try: http://www.dafont.com/bitmap.php</p>
<p># font = ImageFont.truetype('Minecraftia.ttf', 8)</p>
<p>while True:</p>
<p># Draw a black filled box to clear the image.</p>
<p>draw.rectangle((0,0,width,height), outline=0, fill=0)</p>
<p># Shell scripts for system monitoring from here : https://unix.stackexchange.com/questions/119126/command-to-display-memory-usage-disk-usage-and-cpu-load</p>
<p>cmd = "hostname -I | cut -d\' \' -f1"</p>
<p>IP = subprocess.check_output(cmd, shell = True )</p>
<p>cmd = "top -bn1 | grep load | awk ''"</p>
<p>CPU = subprocess.check_output(cmd, shell = True )</p>
<p>cmd = "free -m | awk 'NR==2'"</p>
<p>MemUsage = subprocess.check_output(cmd, shell = True )</p>
<p>cmd = "df -h | awk '$NF==\"/\"'"</p>
<p>Disk = subprocess.check_output(cmd, shell = True )</p>
<p># Write two lines of text.</p>
<p>draw.text((x, top), "IP: " + str(IP), font=font, fill=255)</p>
<p>draw.text((x, top+8), str(CPU), font=font, fill=255)</p>
<p>draw.text((x, top+16), str(MemUsage), font=font, fill=255)</p>
<p>draw.text((x, top+25), str(Disk), font=font, fill=255)</p>
<p># Display image.</p>
<p>disp.image(image)</p>
<p>disp.display()</p>
<p>time.sleep(.1)</p></td>
</tr>
</tbody>
</table>

 6.2 Run code and test result

cd /home/pi/RaspberryPi-Car/basic\_project/OledModule

sudo python3 bp6\_oled\_stats.py

After running the code, the OLED display shows the IP address, CPU,
running memory and RAM information of the Raspberry Pi.

 6.3 Code2

<table>
<tbody>
<tr class="odd">
<td><p>import time</p>
<p>import RPi.GPIO as GPIO</p>
<p>import time</p>
<p>GPIO.setmode(GPIO.BCM)</p>
<p>import Adafruit_GPIO.SPI as SPI</p>
<p>import Adafruit_SSD1306</p>
<p>from PIL import Image</p>
<p>from PIL import ImageDraw</p>
<p>from PIL import ImageFont</p>
<p>#define GPIO pin</p>
<p>GPIO_TRIGGER = 14</p>
<p>GPIO_ECHO = 4</p>
<p>#set GPIO mode (IN / OUT)</p>
<p>GPIO.setup(GPIO_TRIGGER, GPIO.OUT)</p>
<p>GPIO.setup(GPIO_ECHO, GPIO.IN)</p>
<p>def distance():</p>
<p># 10us is the trigger signal</p>
<p>GPIO.output(GPIO_TRIGGER, GPIO.HIGH)</p>
<p>time.sleep(0.00001) #10us</p>
<p>GPIO.output(GPIO_TRIGGER, GPIO.LOW)</p>
<p>while not GPIO.input(GPIO_ECHO):</p>
<p>pass</p>
<p>t1 = time.time()</p>
<p>while GPIO.input(GPIO_ECHO):</p>
<p>pass</p>
<p>t2 = time.time()</p>
<p>print("distance is %d " % (((t2 - t1)* 340 / 2) * 100))</p>
<p>time.sleep(0.01)</p>
<p>return ((t2 - t1)* 340 / 2) * 100</p>
<p>import subprocess</p>
<p># Raspberry Pi pin configuration:</p>
<p>RST = None # on the PiOLED this pin isnt used</p>
<p># Note the following are only used with SPI:</p>
<p>DC = 23</p>
<p>SPI_PORT = 0</p>
<p>SPI_DEVICE = 0</p>
<p># Beaglebone Black pin configuration:</p>
<p># 128x64 display with hardware I2C:</p>
<p>disp = Adafruit_SSD1306.SSD1306_128_64(rst=RST)</p>
<p># Initialize library.</p>
<p>disp.begin()</p>
<p># Clear display.</p>
<p>disp.clear()</p>
<p>disp.display()</p>
<p># Create blank image for drawing.</p>
<p># Make sure to create image with mode '1' for 1-bit color.</p>
<p>width = disp.width</p>
<p>height = disp.height</p>
<p>image = Image.new('1', (width, height))</p>
<p># Get drawing object to draw on image.</p>
<p>draw = ImageDraw.Draw(image)</p>
<p># Draw a black filled box to clear the image.</p>
<p>draw.rectangle((0,0,width,height), outline=0, fill=0)</p>
<p># Draw some shapes.</p>
<p># First define some constants to allow easy resizing of shapes.</p>
<p>padding = -2</p>
<p>top = padding</p>
<p>bottom = height-padding</p>
<p># Move left to right keeping track of the current x position for drawing shapes.</p>
<p>x = 0</p>
<p># Load default font.</p>
<p>font = ImageFont.load_default()</p>
<p># Alternatively load a TTF font. Make sure the .ttf font file is in the same directory as the python script!</p>
<p># Some other nice fonts to try: http://www.dafont.com/bitmap.php</p>
<p># font = ImageFont.truetype('Minecraftia.ttf', 8)</p>
<p>while True:</p>
<p>dist = int(distance()) # round numbers</p>
<p>print("Measured Distance =  cm".format(dist)) #,Keep two decimal places</p>
<p># Draw a black filled box to clear the image.</p>
<p>draw.rectangle((0,0,width,height), outline=0, fill=0)</p>
<p># Write two lines of text.</p>
<p>draw.text((x, top), "Distance: " , font=font, fill=255)</p>
<p>draw.text((x, top+8), str(dist), font=font, fill=255)</p>
<p># Display image.</p>
<p>disp.image(image)</p>
<p>disp.display()</p>
<p>time.sleep(.1)</p></td>
</tr>
</tbody>
</table>

 

 6.4 Run code 2 and test result

cd /home/pi/RaspberryPi-Car/basic\_project/OledModule

sudo python3 bp6\_2oled\_ultrasonic.py

After running the code, the terminal will print out the distance
measured by the ultrasonic sensor, and the value measured by ultrasound
will also be displayed on the OLED display.

![](/media/9942ee0f3e21fd3747116750f8d9c429.png)

### 7.Drive Motor

    We use two TB6612 motor driver chips to drive four motors, that is
    to say, each motor of the car can be controlled respectively.

 7.1 **[Schematic](C:/Users/Administrator/AppData/Local/youdao/dict/Application/8.9.9.0/resultui/html/index.html#/javascript:;) [Diagram](C:/Users/Administrator/AppData/Local/youdao/dict/Application/8.9.9.0/resultui/html/index.html#/javascript:;)**

![](/media/8aaf6fe2a063508dc946a8242a3e2e6f.png)

<table>
<tbody>
<tr class="odd">
<td><p>Motor Drive BCM Pin:</p>
<p>Left（M2）: direction control：GPIO20 GPIO21 speed PWM：GPIO 0</p>
<p>left（M1）: direction control：GPIO22 GPIO23 speed PWM：GPIO 1</p>
<p>Right（M3）: direction control：GPIO24 GPIO25 speed PWM：GPIO 12</p>
<p>Right（M4）: direction control：GPIO26 GPIO27 speed PWM：GPIO 13</p></td>
</tr>
</tbody>
</table>

 7.2 Code

<table>
<tbody>
<tr class="odd">
<td><p>import RPi.GPIO as GPIO</p>
<p>import time</p>
<p>GPIO.setwarnings(False)</p>
<p># Control M2 motor</p>
<p>L_IN1 = 20</p>
<p>L_IN2 = 21</p>
<p>L_PWM1 = 0</p>
<p># Control M1 motor</p>
<p>L_IN3 = 22</p>
<p>L_IN4 = 23</p>
<p>L_PWM2 = 1</p>
<p># Control M3 motor</p>
<p>R_IN1 = 24</p>
<p>R_IN2 = 25</p>
<p>R_PWM1 = 12</p>
<p># Control M4 motor</p>
<p>R_IN3 = 26</p>
<p>R_IN4 = 27</p>
<p>R_PWM2 = 13</p>
<p>GPIO.setmode(GPIO.BCM) # use BCM numbers</p>
<p>#set the MOTOR Driver Pin OUTPUT mode</p>
<p>GPIO.setup(L_IN1,GPIO.OUT)</p>
<p>GPIO.setup(L_IN2,GPIO.OUT)</p>
<p>GPIO.setup(L_PWM1,GPIO.OUT)</p>
<p>GPIO.setup(L_IN3,GPIO.OUT)</p>
<p>GPIO.setup(L_IN4,GPIO.OUT)</p>
<p>GPIO.setup(L_PWM2,GPIO.OUT)</p>
<p>GPIO.setup(R_IN1,GPIO.OUT)</p>
<p>GPIO.setup(R_IN2,GPIO.OUT)</p>
<p>GPIO.setup(R_PWM1,GPIO.OUT)</p>
<p>GPIO.setup(R_IN3,GPIO.OUT)</p>
<p>GPIO.setup(R_IN4,GPIO.OUT)</p>
<p>GPIO.setup(R_PWM2,GPIO.OUT)</p>
<p>GPIO.output(L_IN1,GPIO.LOW)</p>
<p>GPIO.output(L_IN2,GPIO.LOW)</p>
<p>GPIO.output(L_IN3,GPIO.LOW)</p>
<p>GPIO.output(L_IN4,GPIO.LOW)</p>
<p>GPIO.output(R_IN1,GPIO.LOW)</p>
<p>GPIO.output(R_IN2,GPIO.LOW)</p>
<p>GPIO.output(R_IN3,GPIO.LOW)</p>
<p>GPIO.output(R_IN4,GPIO.LOW)</p>
<p>#set pwm frequence to 1000hz</p>
<p>pwm_R1 = GPIO.PWM(R_PWM1,100)</p>
<p>pwm_R2 = GPIO.PWM(R_PWM2,100)</p>
<p>pwm_L1 = GPIO.PWM(L_PWM1,100)</p>
<p>pwm_L2 = GPIO.PWM(L_PWM2,100)</p>
<p>#set inital duty cycle to 0</p>
<p>pwm_R1.start(0)</p>
<p>pwm_L1.start(0)</p>
<p>pwm_R2.start(0)</p>
<p>pwm_L2.start(0)</p>
<p>while True:</p>
<p>GPIO.output(L_IN1,GPIO.LOW) #Upper Left forward</p>
<p>GPIO.output(L_IN2,GPIO.HIGH)</p>
<p>pwm_L1.ChangeDutyCycle(50)</p>
<p>GPIO.output(L_IN3,GPIO.HIGH) #Lower left forward</p>
<p>GPIO.output(L_IN4,GPIO.LOW)</p>
<p>pwm_L2.ChangeDutyCycle(50)</p>
<p>GPIO.output(R_IN1,GPIO.HIGH) #Upper Right forward</p>
<p>GPIO.output(R_IN2,GPIO.LOW)</p>
<p>pwm_R1.ChangeDutyCycle(50)</p>
<p>GPIO.output(R_IN3,GPIO.LOW) #Lower Right forward</p>
<p>GPIO.output(R_IN4,GPIO.HIGH)</p>
<p>pwm_R2.ChangeDutyCycle(50)</p>
<p>#stop pwm</p>
<p>pwm_R1.stop()</p>
<p>pwm_L1.stop()</p>
<p>pwm_R2.stop()</p>
<p>pwm_L2.stop()</p>
<p>sleep(1)</p>
<p>GPIO.cleanup() #release all GPIO</p></td>
</tr>
</tbody>
</table>

 7.3 Run code and test result

Note: Run the code and the car will go forward. If you connect the power
and network cables, remember to lift the car first before running it so
as to avoid damaging the device.

cd /home/pi/RaspberryPi-Car/basic\_project

sudo python3 bp7\_motor\_test.py

Run the code, then the car will go forward.

### 8.Infrared Receiver

**NEC Protocol：**

  - 8 bit address and 8 bit command length.

  - Extended mode available, doubling the address size.

  - Address and command are transmitted twice for reliability.

  - Pulse distance modulation.

  - Carrier frequency of 38kHz.

  - Bit time of 1.125ms or 2.25ms.
    
    NEC IR transmission protocol：
    
    ![](/media/a2461ccc332a5a94425c5981863ccec3.png)

Notice from Figure 1 that it takes:

Send 9ms+4.5ms leading code firstly, then address, inverse, command and
inverse.

The inverse code is used to verify and improve the accuracy of keys
value.

The four bytes of data bits are each sent least significant bit first.
Figure 1 illustrates the format of an NEC IR transmission frame, for an
address of 00h (00000000b) and a command of ADh (10101101b).

![](/media/2a8899cf0db571f7e2d1e55746237405.png)

The NEC protocol uses pulse distance encoding of the bits. Each pulse is
a 562.5µs long 38kHz carrier burst (about 21 cycles). A logical "1"
takes 2.25ms to transmit, while a logical "0" is only half of that,
being 1.125ms. The recommended carrier duty-cycle is 1/4 or 1/3.

Logical‘0’– a 562.5µs pulse burst followed by a 562.5µs space, with a
total transmit time of 1.125ms

Logical‘1’– a 562.5µs pulse burst followed by a 1.6875ms space, with a
total transmit time of 2.25ms

Note: a 562.5µs pulse and a 1.6875ms space combine 2.23ms, 562.5µs pulse
is high level, therefore, the rest is low level.

<table>
<tbody>
<tr class="odd">
<td>Infrared receiving pin: GPIO 15</td>
</tr>
</tbody>
</table>

 8.1 Code

<table>
<tbody>
<tr class="odd">
<td><p>import RPi.GPIO as GPIO</p>
<p>import time</p>
<p>PIN = 15;</p>
<p>GPIO.setmode(GPIO.BCM)</p>
<p>GPIO.setup(PIN,GPIO.IN,GPIO.PUD_UP)</p>
<p>print("irm test start...")</p>
<p>def exec_cmd(key_val):</p>
<p>if(key_val==0x46):</p>
<p>print("Button up")</p>
<p>elif(key_val==0x44):</p>
<p>print("Button left")</p>
<p>elif(key_val==0x40):</p>
<p>print("Button ok")</p>
<p>elif(key_val==0x43):</p>
<p>print("Button right")</p>
<p>elif(key_val==0x15):</p>
<p>print("Button down")</p>
<p>elif(key_val==0x16):</p>
<p>print("Button 1")</p>
<p>elif(key_val==0x19):</p>
<p>print("Button 2")</p>
<p>elif(key_val==0x0d):</p>
<p>print("Button 3")</p>
<p>elif(key_val==0x0c):</p>
<p>print("Button 4")</p>
<p>elif(key_val==0x18):</p>
<p>print("Button 5")</p>
<p>elif(key_val==0x5e):</p>
<p>print("Button 6")</p>
<p>elif(key_val==0x08):</p>
<p>print("Button 7")</p>
<p>elif(key_val==0x1c):</p>
<p>print("Button 8")</p>
<p>elif(key_val==0x5a):</p>
<p>print("Button 9")</p>
<p>elif(key_val==0x42):</p>
<p>print("Button *")</p>
<p>elif(key_val==0x52):</p>
<p>print("Button 0")</p>
<p>elif(key_val==0x4a):</p>
<p>print("Button #")</p>
<p>try:</p>
<p>while True:</p>
<p>if GPIO.input(PIN) == 0:</p>
<p>count = 0</p>
<p>while GPIO.input(PIN) == 0 and count &lt; 200: # Wait for 9ms LOW level boot code and exit the loop if it exceeds 1.2ms</p>
<p>count += 1</p>
<p>time.sleep(0.00006)</p>
<p>count = 0</p>
<p>while GPIO.input(PIN) == 1 and count &lt; 80: # Wait for a 4.5ms HIGH level boot code and exit the loop if it exceeds 0.48ms</p>
<p>count += 1</p>
<p>time.sleep(0.00006)</p>
<p>idx = 0 # byte count variable</p>
<p>cnt = 0 #Variable per byte bit</p>
<p>#There are 4 bytes in total. The first byte is the address code, the second is the address inverse code,</p>
<p>#the third is the control command data of the corresponding button, and the fourth is the control command inverse code</p>
<p>data = [0,0,0,0]</p>
<p>for i in range(0,32): # Start receiving 32BITE data</p>
<p>count = 0</p>
<p>while GPIO.input(PIN) == 0 and count &lt; 15: # Wait for the LOW LOW level of 562.5US to pass and exit the loop if it exceeds 900US</p>
<p>count += 1</p>
<p>time.sleep(0.00006)</p>
<p>count = 0</p>
<p>while GPIO.input(PIN) == 1 and count &lt; 40: # waits for logical HIGH level to pass and exits the loop if it exceeds 2.4ms</p>
<p>count += 1</p>
<p>time.sleep(0.00006)</p>
<p># if count&gt;8, that is, the logical time is greater than 0.54+0.562=1.12ms, that is,</p>
<p>#the period is greater than the logical 0 period, that is equivalent to receiving logical 1</p>
<p>if count &gt; 8:</p>
<p>data[idx] |= 1&lt;&lt;cnt #When idx=0 is the first data data[idx] = data[idx] | 1&lt;&lt;cnt 00000001 &lt;&lt;1 == 0000 0010</p>
<p>if cnt == 7: #With 8 byte</p>
<p>cnt = 0 #Displacement qing 0</p>
<p>idx += 1 #Store the next data</p>
<p>else:</p>
<p>cnt += 1 #The shift adds 1</p>
<p>#Determine whether address code + address inverse code =0xff, control code + control inverse code = 0xFF</p>
<p>if data[0]+data[1] == 0xFF and data[2]+data[3] == 0xFF:</p>
<p>print("Get the key: 0x%02x" %data[2]) #Data [2] is the control code we need</p>
<p>exec_cmd(data[2])</p>
<p>except KeyboardInterrupt:</p>
<p>GPIO.cleanup()</p></td>
</tr>
</tbody>
</table>

 8.2 Run code and test result

cd /home/pi/RaspberryPi-Car/basic\_project

sudo python3 bp8\_ir\_remote.py

After running the code, point at infrared receiver module with the
infrared remote control and press keys. The terminal will print out the
received signal values, as shown in the figure below:

![](/media/11879d925698e70323c3ee810d5b7391.png)

### 9.IR Remote Control Car

We have learned motor drivers, 8\*16 dot matrix and infrared remote
control. Let's make the infrared remote control car.

 9.1 Code

<table>
<tbody>
<tr class="odd">
<td><p>import RPi.GPIO as GPIO</p>
<p>import time</p>
<p>PIN = 15;</p>
<p>SCLK = 8</p>
<p>DIO = 9</p>
<p># Display pattern data</p>
<p>matrix_smile = (0x00, 0x00, 0x38, 0x40, 0x40, 0x40, 0x3a, 0x02, 0x02, 0x3a, 0x40, 0x40, 0x40, 0x38, 0x00, 0x00)</p>
<p>matrix_forward = (0x00, 0x00, 0x00, 0x00, 0x12, 0x24, 0x48, 0x90, 0x90, 0x48, 0x24, 0x12, 0x00, 0x00, 0x00, 0x00)</p>
<p>matrix_back = (0x00, 0x00, 0x00, 0x00, 0x48, 0x24, 0x12, 0x09, 0x09, 0x12, 0x24, 0x48, 0x00, 0x00, 0x00, 0x00)</p>
<p>matrix_left = (0x00, 0x00, 0x00, 0x00, 0x18, 0x24, 0x42, 0x99, 0x24, 0x42, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00)</p>
<p>matrix_right = (0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x42, 0x24, 0x99, 0x42, 0x24, 0x18, 0x00, 0x00, 0x00, 0x00)</p>
<p>GPIO.setmode(GPIO.BCM)</p>
<p>GPIO.setup(PIN,GPIO.IN,GPIO.PUD_UP)</p>
<p>GPIO.setup(SCLK,GPIO.OUT)</p>
<p>GPIO.setup(DIO,GPIO.OUT)</p>
<p>print("irm test start...")</p>
<p># Control M2 motor</p>
<p>L_IN1 = 20</p>
<p>L_IN2 = 21</p>
<p>L_PWM1 = 0</p>
<p># Control M1 motor</p>
<p>L_IN3 = 22</p>
<p>L_IN4 = 23</p>
<p>L_PWM2 = 1</p>
<p># Control M3 motor</p>
<p>R_IN1 = 24</p>
<p>R_IN2 = 25</p>
<p>R_PWM1 = 12</p>
<p># Control M4 motor</p>
<p>R_IN3 = 26</p>
<p>R_IN4 = 27</p>
<p>R_PWM2 = 13</p>
<p>GPIO.setmode(GPIO.BCM) # use BCM numbers</p>
<p>#set the MOTOR Driver Pin OUTPUT mode</p>
<p>GPIO.setup(L_IN1,GPIO.OUT)</p>
<p>GPIO.setup(L_IN2,GPIO.OUT)</p>
<p>GPIO.setup(L_PWM1,GPIO.OUT)</p>
<p>GPIO.setup(L_IN3,GPIO.OUT)</p>
<p>GPIO.setup(L_IN4,GPIO.OUT)</p>
<p>GPIO.setup(L_PWM2,GPIO.OUT)</p>
<p>GPIO.setup(R_IN1,GPIO.OUT)</p>
<p>GPIO.setup(R_IN2,GPIO.OUT)</p>
<p>GPIO.setup(R_PWM1,GPIO.OUT)</p>
<p>GPIO.setup(R_IN3,GPIO.OUT)</p>
<p>GPIO.setup(R_IN4,GPIO.OUT)</p>
<p>GPIO.setup(R_PWM2,GPIO.OUT)</p>
<p>GPIO.output(L_IN1,GPIO.LOW)</p>
<p>GPIO.output(L_IN2,GPIO.LOW)</p>
<p>GPIO.output(L_IN3,GPIO.LOW)</p>
<p>GPIO.output(L_IN4,GPIO.LOW)</p>
<p>GPIO.output(R_IN1,GPIO.LOW)</p>
<p>GPIO.output(R_IN2,GPIO.LOW)</p>
<p>GPIO.output(R_IN3,GPIO.LOW)</p>
<p>GPIO.output(R_IN4,GPIO.LOW)</p>
<p>#set pwm frequence to 1000hz</p>
<p>pwm_R1 = GPIO.PWM(R_PWM1,100)</p>
<p>pwm_R2 = GPIO.PWM(R_PWM2,100)</p>
<p>pwm_L1 = GPIO.PWM(L_PWM1,100)</p>
<p>pwm_L2 = GPIO.PWM(L_PWM2,100)</p>
<p>#set inital duty cycle to 0</p>
<p>pwm_R1.start(0)</p>
<p>pwm_L1.start(0)</p>
<p>pwm_R2.start(0)</p>
<p>pwm_L2.start(0)</p>
<p>def nop():</p>
<p>time.sleep(0.000001)</p>
<p>def nop2():</p>
<p>time.sleep(0.01)</p>
<p>def start():</p>
<p>GPIO.output(SCLK,1)</p>
<p>nop()</p>
<p>GPIO.output(DIO,1)</p>
<p>nop()</p>
<p>GPIO.output(DIO,0)</p>
<p>nop()</p>
<p>GPIO.output(SCLK,0)</p>
<p>def send_date(date):</p>
<p>for i in range(0,8):</p>
<p>GPIO.output(SCLK,0)</p>
<p>nop()</p>
<p>if date &amp; 0x01:</p>
<p>GPIO.output(DIO,1)</p>
<p>else:</p>
<p>GPIO.output(DIO,0)</p>
<p>nop()</p>
<p>GPIO.output(SCLK,1)</p>
<p>nop()</p>
<p>date &gt;&gt;= 1</p>
<p>GPIO.output(SCLK,0)</p>
<p>def end():</p>
<p>GPIO.output(SCLK,0)</p>
<p>nop()</p>
<p>GPIO.output(DIO,0)</p>
<p>nop()</p>
<p>GPIO.output(SCLK,1)</p>
<p>nop()</p>
<p>GPIO.output(DIO,1)</p>
<p>nop()</p>
<p>def matrix_display(matrix_value):</p>
<p>start()</p>
<p>send_date(0xc0)</p>
<p>for i in range(0,16):</p>
<p>send_date(matrix_value[i])</p>
<p>end()</p>
<p>start()</p>
<p>send_date(0x8A)</p>
<p>end()</p>
<p>def exec_cmd(key_val):</p>
<p>if(key_val==0x46):</p>
<p>print("Button up")</p>
<p>matrix_display(matrix_forward)</p>
<p>GPIO.output(L_IN1,GPIO.LOW) #Upper Left forward</p>
<p>GPIO.output(L_IN2,GPIO.HIGH)</p>
<p>pwm_L1.ChangeDutyCycle(50)</p>
<p>GPIO.output(L_IN3,GPIO.HIGH) #Lower left forward</p>
<p>GPIO.output(L_IN4,GPIO.LOW)</p>
<p>pwm_L2.ChangeDutyCycle(50)</p>
<p>GPIO.output(R_IN1,GPIO.HIGH) #Upper Right forward</p>
<p>GPIO.output(R_IN2,GPIO.LOW)</p>
<p>pwm_R1.ChangeDutyCycle(50)</p>
<p>GPIO.output(R_IN3,GPIO.LOW) #Lower Right forward</p>
<p>GPIO.output(R_IN4,GPIO.HIGH)</p>
<p>pwm_R2.ChangeDutyCycle(50)</p>
<p>elif(key_val==0x44):</p>
<p>print("Button left")</p>
<p>matrix_display(matrix_left)</p>
<p>GPIO.output(L_IN1,GPIO.HIGH)</p>
<p>GPIO.output(L_IN2,GPIO.LOW)</p>
<p>pwm_L1.ChangeDutyCycle(100)</p>
<p>GPIO.output(L_IN3,GPIO.LOW)</p>
<p>GPIO.output(L_IN4,GPIO.HIGH)</p>
<p>pwm_L2.ChangeDutyCycle(100)</p>
<p>GPIO.output(R_IN1,GPIO.HIGH) #Upper Right forward</p>
<p>GPIO.output(R_IN2,GPIO.LOW)</p>
<p>pwm_R1.ChangeDutyCycle(100)</p>
<p>GPIO.output(R_IN3,GPIO.LOW) #Lower Right forward</p>
<p>GPIO.output(R_IN4,GPIO.HIGH)</p>
<p>pwm_R2.ChangeDutyCycle(100)</p>
<p>elif(key_val==0x40):</p>
<p>print("Button ok")</p>
<p>matrix_display(matrix_smile)</p>
<p>pwm_L1.ChangeDutyCycle(0)</p>
<p>pwm_L2.ChangeDutyCycle(0)</p>
<p>pwm_R1.ChangeDutyCycle(0)</p>
<p>pwm_R2.ChangeDutyCycle(0)</p>
<p>elif(key_val==0x43):</p>
<p>print("Button right")</p>
<p>matrix_display(matrix_right)</p>
<p>GPIO.output(L_IN1,GPIO.LOW) #Upper Left forward</p>
<p>GPIO.output(L_IN2,GPIO.HIGH)</p>
<p>pwm_L1.ChangeDutyCycle(100)</p>
<p>GPIO.output(L_IN3,GPIO.HIGH) #Lower left forward</p>
<p>GPIO.output(L_IN4,GPIO.LOW)</p>
<p>pwm_L2.ChangeDutyCycle(100)</p>
<p>GPIO.output(R_IN1,GPIO.LOW) #Upper Right forward</p>
<p>GPIO.output(R_IN2,GPIO.HIGH)</p>
<p>pwm_R1.ChangeDutyCycle(100)</p>
<p>GPIO.output(R_IN3,GPIO.HIGH) #Lower Right forward</p>
<p>GPIO.output(R_IN4,GPIO.LOW)</p>
<p>pwm_R2.ChangeDutyCycle(100)</p>
<p>elif(key_val==0x15):</p>
<p>print("Button down")</p>
<p>matrix_display(matrix_back)</p>
<p>GPIO.output(L_IN1,GPIO.HIGH)</p>
<p>GPIO.output(L_IN2,GPIO.LOW)</p>
<p>pwm_L1.ChangeDutyCycle(50)</p>
<p>GPIO.output(L_IN3,GPIO.LOW)</p>
<p>GPIO.output(L_IN4,GPIO.HIGH)</p>
<p>pwm_L2.ChangeDutyCycle(50)</p>
<p>GPIO.output(R_IN1,GPIO.LOW)</p>
<p>GPIO.output(R_IN2,GPIO.HIGH)</p>
<p>pwm_R1.ChangeDutyCycle(50)</p>
<p>GPIO.output(R_IN3,GPIO.HIGH)</p>
<p>GPIO.output(R_IN4,GPIO.LOW)</p>
<p>pwm_R2.ChangeDutyCycle(50)</p>
<p>elif(key_val==0x16):</p>
<p>print("Button 1")</p>
<p>elif(key_val==0x19):</p>
<p>print("Button 2")</p>
<p>elif(key_val==0x0d):</p>
<p>print("Button 3")</p>
<p>elif(key_val==0x0c):</p>
<p>print("Button 4")</p>
<p>elif(key_val==0x18):</p>
<p>print("Button 5")</p>
<p>elif(key_val==0x5e):</p>
<p>print("Button 6")</p>
<p>elif(key_val==0x08):</p>
<p>print("Button 7")</p>
<p>elif(key_val==0x1c):</p>
<p>print("Button 8")</p>
<p>elif(key_val==0x5a):</p>
<p>print("Button 9")</p>
<p>elif(key_val==0x42):</p>
<p>print("Button *")</p>
<p>elif(key_val==0x52):</p>
<p>print("Button 0")</p>
<p>elif(key_val==0x4a):</p>
<p>print("Button #")</p>
<p>try:</p>
<p>while True:</p>
<p>if GPIO.input(PIN) == 0:</p>
<p>count = 0</p>
<p>while GPIO.input(PIN) == 0 and count &lt; 200: # Wait for 9ms LOW level boot code and exit the loop if it exceeds 1.2ms</p>
<p>count += 1</p>
<p>time.sleep(0.00006)</p>
<p>count = 0</p>
<p>while GPIO.input(PIN) == 1 and count &lt; 80: # Wait for a 4.5ms HIGH level boot code and exit the loop if it exceeds 0.48ms</p>
<p>count += 1</p>
<p>time.sleep(0.00006)</p>
<p>idx = 0 # byte count variable</p>
<p>cnt = 0 #Variable per byte bit</p>
<p>#There are 4 bytes in total. The first byte is the address code, the second is the address inverse code,</p>
<p>#the third is the control command data of the corresponding button, and the fourth is the control command inverse code</p>
<p>data = [0,0,0,0]</p>
<p>for i in range(0,32): # Start receiving 32BITE data</p>
<p>count = 0</p>
<p>while GPIO.input(PIN) == 0 and count &lt; 15: # Wait for the LOW LOW level of 562.5US to pass and exit the loop if it exceeds 900US</p>
<p>count += 1</p>
<p>time.sleep(0.00006)</p>
<p>count = 0</p>
<p>while GPIO.input(PIN) == 1 and count &lt; 40: # waits for logical HIGH level to pass and exits the loop if it exceeds 2.4ms</p>
<p>count += 1</p>
<p>time.sleep(0.00006)</p>
<p># if count&gt;8, that is, the logical time is greater than 0.54+0.562=1.12ms, that is,</p>
<p>#the period is greater than the logical 0 period, that is equivalent to receiving logical 1</p>
<p>if count &gt; 8:</p>
<p>data[idx] |= 1&lt;&lt;cnt #When idx=0 is the first data data[idx] = data[idx] | 1&lt;&lt;cnt 00000001 &lt;&lt;1 == 0000 0010</p>
<p>if cnt == 7: #With 8 byte</p>
<p>cnt = 0 #Displacement qing 0</p>
<p>idx += 1 #Store the next data</p>
<p>else:</p>
<p>cnt += 1 #The shift adds 1</p>
<p>#Determine whether address code + address inverse code =0xff, control code + control inverse code = 0xFF</p>
<p>if data[0]+data[1] == 0xFF and data[2]+data[3] == 0xFF:</p>
<p>print("Get the key: 0x%02x" %data[2]) #Data [2] is the control code we need</p>
<p>exec_cmd(data[2])</p>
<p>except KeyboardInterrupt:</p>
<p>GPIO.cleanup()</p></td>
</tr>
</tbody>
</table>

 9.2 Run code and test result

cd /home/pi/RaspberryPi-Car/basic\_project

sudo python3 bp9\_ir\_car.py

After running test code, press the keys of the remote control,then the
car will move and the dot matrix will show the corresponding patterns.

### 10.Line Tracking Car
    
    The three-channel line tracking sensor has three sensor. When it
    detects black lines, the value will be 1.
    
    The middle sensor detects black lines: the car will go forward.
    
    When the middle one doesn’t detect the black line：
    
    Left sensor detects black lines and right one doesn’t detect black
    lines；the car will turn left.
    
    The left one doesn’t detect black lines, the right one detects
    ones；the car will turn right.
    
    Neither left one nor right one detects black lines;the car will stop
    
    Both of two sensors detect black lines；the car will stop.

<table>
<tbody>
<tr class="odd">
<td>Middle tracking sensor</td>
<td>left line tracking sensor</td>
<td>Right line tracking sensor</td>
<td>Status</td>
</tr>
<tr class="even">
<td>1</td>
<td>-</td>
<td>-</td>
<td>Go forward</td>
</tr>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>0</td>
<td>Turn left</td>
</tr>
<tr class="even">
<td></td>
<td>0</td>
<td>1</td>
<td>Turn right</td>
</tr>
<tr class="odd">
<td></td>
<td>0</td>
<td>0</td>
<td>stop</td>
</tr>
<tr class="even">
<td></td>
<td>1</td>
<td>1</td>
<td>stop</td>
</tr>
</tbody>
</table>

 10.1 Code

<table>
<tbody>
<tr class="odd">
<td><p>import RPi.GPIO as GPIO</p>
<p>import time</p>
<p>GPIO.setwarnings(False)</p>
<p># Control M2 motor</p>
<p>L_IN1 = 20</p>
<p>L_IN2 = 21</p>
<p>L_PWM1 = 0</p>
<p># Control M1 motor</p>
<p>L_IN3 = 22</p>
<p>L_IN4 = 23</p>
<p>L_PWM2 = 1</p>
<p># Control M3 motor</p>
<p>R_IN1 = 24</p>
<p>R_IN2 = 25</p>
<p>R_PWM1 = 12</p>
<p># Control M4 motor</p>
<p>R_IN3 = 26</p>
<p>R_IN4 = 27</p>
<p>R_PWM2 = 13</p>
<p>#tracking pin</p>
<p>trackingPin1 = 17</p>
<p>trackingPin2 = 18</p>
<p>trackingPin3 = 19</p>
<p>GPIO.setmode(GPIO.BCM) # use BCM numbers</p>
<p>GPIO.setup(trackingPin1,GPIO.IN) # set trackingPin INPUT mode</p>
<p>GPIO.setup(trackingPin2,GPIO.IN)</p>
<p>GPIO.setup(trackingPin3,GPIO.IN)</p>
<p>#set the MOTOR Driver Pin OUTPUT mode</p>
<p>GPIO.setup(L_IN1,GPIO.OUT)</p>
<p>GPIO.setup(L_IN2,GPIO.OUT)</p>
<p>GPIO.setup(L_PWM1,GPIO.OUT)</p>
<p>GPIO.setup(L_IN3,GPIO.OUT)</p>
<p>GPIO.setup(L_IN4,GPIO.OUT)</p>
<p>GPIO.setup(L_PWM2,GPIO.OUT)</p>
<p>GPIO.setup(R_IN1,GPIO.OUT)</p>
<p>GPIO.setup(R_IN2,GPIO.OUT)</p>
<p>GPIO.setup(R_PWM1,GPIO.OUT)</p>
<p>GPIO.setup(R_IN3,GPIO.OUT)</p>
<p>GPIO.setup(R_IN4,GPIO.OUT)</p>
<p>GPIO.setup(R_PWM2,GPIO.OUT)</p>
<p>GPIO.output(L_IN1,GPIO.LOW)</p>
<p>GPIO.output(L_IN2,GPIO.LOW)</p>
<p>GPIO.output(L_IN3,GPIO.LOW)</p>
<p>GPIO.output(L_IN4,GPIO.LOW)</p>
<p>GPIO.output(R_IN1,GPIO.LOW)</p>
<p>GPIO.output(R_IN2,GPIO.LOW)</p>
<p>GPIO.output(R_IN3,GPIO.LOW)</p>
<p>GPIO.output(R_IN4,GPIO.LOW)</p>
<p>#set pwm frequence to 1000hz</p>
<p>pwm_R1 = GPIO.PWM(R_PWM1,100)</p>
<p>pwm_R2 = GPIO.PWM(R_PWM2,100)</p>
<p>pwm_L1 = GPIO.PWM(L_PWM1,100)</p>
<p>pwm_L2 = GPIO.PWM(L_PWM2,100)</p>
<p>#set inital duty cycle to 0</p>
<p>pwm_R1.start(0)</p>
<p>pwm_L1.start(0)</p>
<p>pwm_R2.start(0)</p>
<p>pwm_L2.start(0)</p>
<p># car forward</p>
<p>def car_forward():</p>
<p>GPIO.output(L_IN1,GPIO.LOW)</p>
<p>GPIO.output(L_IN2,GPIO.HIGH)</p>
<p>pwm_L1.ChangeDutyCycle(30)</p>
<p>GPIO.output(L_IN3,GPIO.HIGH)</p>
<p>GPIO.output(L_IN4,GPIO.LOW)</p>
<p>pwm_L2.ChangeDutyCycle(30)</p>
<p>GPIO.output(R_IN1,GPIO.HIGH)</p>
<p>GPIO.output(R_IN2,GPIO.LOW)</p>
<p>pwm_R1.ChangeDutyCycle(30)</p>
<p>GPIO.output(R_IN3,GPIO.LOW)</p>
<p>GPIO.output(R_IN4,GPIO.HIGH)</p>
<p>pwm_R2.ChangeDutyCycle(30)</p>
<p># car left</p>
<p>def car_left():</p>
<p>GPIO.output(L_IN1,GPIO.HIGH)</p>
<p>GPIO.output(L_IN2,GPIO.LOW)</p>
<p>pwm_L1.ChangeDutyCycle(50)</p>
<p>GPIO.output(L_IN3,GPIO.LOW)</p>
<p>GPIO.output(L_IN4,GPIO.HIGH)</p>
<p>pwm_L2.ChangeDutyCycle(50)</p>
<p>GPIO.output(R_IN1,GPIO.HIGH)</p>
<p>GPIO.output(R_IN2,GPIO.LOW)</p>
<p>pwm_R1.ChangeDutyCycle(50)</p>
<p>GPIO.output(R_IN3,GPIO.LOW)</p>
<p>GPIO.output(R_IN4,GPIO.HIGH)</p>
<p>pwm_R2.ChangeDutyCycle(50)</p>
<p># car right</p>
<p>def car_right():</p>
<p>GPIO.output(L_IN1,GPIO.LOW)</p>
<p>GPIO.output(L_IN2,GPIO.HIGH)</p>
<p>pwm_L1.ChangeDutyCycle(50)</p>
<p>GPIO.output(L_IN3,GPIO.HIGH)</p>
<p>GPIO.output(L_IN4,GPIO.LOW)</p>
<p>pwm_L2.ChangeDutyCycle(50)</p>
<p>GPIO.output(R_IN1,GPIO.LOW)</p>
<p>GPIO.output(R_IN2,GPIO.HIGH)</p>
<p>pwm_R1.ChangeDutyCycle(50)</p>
<p>GPIO.output(R_IN3,GPIO.HIGH)</p>
<p>GPIO.output(R_IN4,GPIO.LOW)</p>
<p>pwm_R2.ChangeDutyCycle(50)</p>
<p># car stop</p>
<p>def car_stop():</p>
<p>pwm_L1.ChangeDutyCycle(0)</p>
<p>pwm_L2.ChangeDutyCycle(0)</p>
<p>pwm_R1.ChangeDutyCycle(0)</p>
<p>pwm_R2.ChangeDutyCycle(0)</p>
<p>while True:</p>
<p>val1 = GPIO.input(trackingPin1) # read the value</p>
<p>val2 = GPIO.input(trackingPin2)</p>
<p>val3 = GPIO.input(trackingPin3)</p>
<p>if(val2 == 1):</p>
<p>car_forward()</p>
<p>print("forward")</p>
<p>else:</p>
<p>if((val1 == 1) and (val3 == 0)):</p>
<p>car_right()</p>
<p>print("right")</p>
<p>elif((val1 == 0) and (val3 == 1)):</p>
<p>car_left()</p>
<p>print("left")</p>
<p>else:</p>
<p>car_stop()</p>
<p>print("stop")</p>
<p>#stop pwm</p>
<p>pwm_R1.stop()</p>
<p>pwm_L1.stop()</p>
<p>pwm_R2.stop()</p>
<p>pwm_L2.stop()</p>
<p>sleep(1)</p>
<p>GPIO.cleanup() #release all GPIO</p></td>
</tr>
</tbody>
</table>

 10.2 Run code and test result

cd /home/pi/RaspberryPi-Car/basic\_project

sudo python3 bp10\_tracking\_car.py

Run the code and plug in power and place it on a tracking map,then the
car will move along the black line.

### 11.Ultrasonic Following Car

Gauge distance by the ultrasonic detection, make car follow the object
to go forward or backward.

Logical form of the ultrasonic following car

<table>
<tbody>
<tr class="odd">
<td>Distance value detected by the ultrasonic sensor</td>
<td>Ultrasonic Following Car</td>
</tr>
<tr class="even">
<td>&lt;10</td>
<td>Go back</td>
</tr>
<tr class="odd">
<td>10≤distance value≤14</td>
<td>stop</td>
</tr>
<tr class="even">
<td>14&lt;distance value≤50</td>
<td>Go forward</td>
</tr>
<tr class="odd">
<td>&gt;50</td>
<td>stop</td>
</tr>
</tbody>
</table>

 11.1 Code

<table>
<tbody>
<tr class="odd">
<td><p>import RPi.GPIO as GPIO</p>
<p>import time</p>
<p>GPIO.setwarnings(False)</p>
<p>GPIO.setmode(GPIO.BCM) # use BCM numbers</p>
<p>#define GPIO pin</p>
<p>GPIO_TRIGGER = 14</p>
<p>GPIO_ECHO = 4</p>
<p>#set GPIO mode (IN / OUT)</p>
<p>GPIO.setup(GPIO_TRIGGER, GPIO.OUT)</p>
<p>GPIO.setup(GPIO_ECHO, GPIO.IN)</p>
<p>def distance():</p>
<p># 10us is the trigger signal</p>
<p>GPIO.output(GPIO_TRIGGER, True)</p>
<p>time.sleep(0.00001) #10us</p>
<p>GPIO.output(GPIO_TRIGGER, False)</p>
<p>start_time = time.time() # Log the time the program runs to this point</p>
<p>stop_time = time.time() # Log the time the program runs to this point</p>
<p>while GPIO.input(GPIO_ECHO) == 0: #Indicates that the ultrasonic wave has been emitted</p>
<p>start_time = time.time() #Record launch time</p>
<p>while GPIO.input(GPIO_ECHO) == 1: #Indicates that the returned ultrasound has been received</p>
<p>stop_time = time.time() #Record receiving time</p>
<p>time_elapsed = stop_time - start_time #Time difference from transmit to receive</p>
<p>distance = (time_elapsed * 34000) / 2 #Calculate the distance</p>
<p>return distance #Return to calculated distance</p>
<p># Control M2 motor</p>
<p>L_IN1 = 20</p>
<p>L_IN2 = 21</p>
<p>L_PWM1 = 0</p>
<p># Control M1 motor</p>
<p>L_IN3 = 22</p>
<p>L_IN4 = 23</p>
<p>L_PWM2 = 1</p>
<p># Control M3 motor</p>
<p>R_IN1 = 24</p>
<p>R_IN2 = 25</p>
<p>R_PWM1 = 12</p>
<p># Control M4 motor</p>
<p>R_IN3 = 26</p>
<p>R_IN4 = 27</p>
<p>R_PWM2 = 13</p>
<p>#set the MOTOR Driver Pin OUTPUT mode</p>
<p>GPIO.setup(L_IN1,GPIO.OUT)</p>
<p>GPIO.setup(L_IN2,GPIO.OUT)</p>
<p>GPIO.setup(L_PWM1,GPIO.OUT)</p>
<p>GPIO.setup(L_IN3,GPIO.OUT)</p>
<p>GPIO.setup(L_IN4,GPIO.OUT)</p>
<p>GPIO.setup(L_PWM2,GPIO.OUT)</p>
<p>GPIO.setup(R_IN1,GPIO.OUT)</p>
<p>GPIO.setup(R_IN2,GPIO.OUT)</p>
<p>GPIO.setup(R_PWM1,GPIO.OUT)</p>
<p>GPIO.setup(R_IN3,GPIO.OUT)</p>
<p>GPIO.setup(R_IN4,GPIO.OUT)</p>
<p>GPIO.setup(R_PWM2,GPIO.OUT)</p>
<p>GPIO.output(L_IN1,GPIO.LOW)</p>
<p>GPIO.output(L_IN2,GPIO.LOW)</p>
<p>GPIO.output(L_IN3,GPIO.LOW)</p>
<p>GPIO.output(L_IN4,GPIO.LOW)</p>
<p>GPIO.output(R_IN1,GPIO.LOW)</p>
<p>GPIO.output(R_IN2,GPIO.LOW)</p>
<p>GPIO.output(R_IN3,GPIO.LOW)</p>
<p>GPIO.output(R_IN4,GPIO.LOW)</p>
<p>#set pwm frequence to 1000hz</p>
<p>pwm_R1 = GPIO.PWM(R_PWM1,100)</p>
<p>pwm_R2 = GPIO.PWM(R_PWM2,100)</p>
<p>pwm_L1 = GPIO.PWM(L_PWM1,100)</p>
<p>pwm_L2 = GPIO.PWM(L_PWM2,100)</p>
<p>#set inital duty cycle to 0</p>
<p>pwm_R1.start(0)</p>
<p>pwm_L1.start(0)</p>
<p>pwm_R2.start(0)</p>
<p>pwm_L2.start(0)</p>
<p># car forward</p>
<p>def car_forward():</p>
<p>GPIO.output(L_IN1,GPIO.LOW)</p>
<p>GPIO.output(L_IN2,GPIO.HIGH)</p>
<p>pwm_L1.ChangeDutyCycle(30)</p>
<p>GPIO.output(L_IN3,GPIO.HIGH)</p>
<p>GPIO.output(L_IN4,GPIO.LOW)</p>
<p>pwm_L2.ChangeDutyCycle(30)</p>
<p>GPIO.output(R_IN1,GPIO.HIGH)</p>
<p>GPIO.output(R_IN2,GPIO.LOW)</p>
<p>pwm_R1.ChangeDutyCycle(30)</p>
<p>GPIO.output(R_IN3,GPIO.LOW)</p>
<p>GPIO.output(R_IN4,GPIO.HIGH)</p>
<p>pwm_R2.ChangeDutyCycle(30)</p>
<p># car back</p>
<p>def car_back():</p>
<p>GPIO.output(L_IN1,GPIO.HIGH)</p>
<p>GPIO.output(L_IN2,GPIO.LOW)</p>
<p>pwm_L1.ChangeDutyCycle(30)</p>
<p>GPIO.output(L_IN3,GPIO.LOW)</p>
<p>GPIO.output(L_IN4,GPIO.HIGH)</p>
<p>pwm_L2.ChangeDutyCycle(30)</p>
<p>GPIO.output(R_IN1,GPIO.LOW)</p>
<p>GPIO.output(R_IN2,GPIO.HIGH)</p>
<p>pwm_R1.ChangeDutyCycle(30)</p>
<p>GPIO.output(R_IN3,GPIO.HIGH)</p>
<p>GPIO.output(R_IN4,GPIO.LOW)</p>
<p>pwm_R2.ChangeDutyCycle(30)</p>
<p># car stop</p>
<p>def car_stop():</p>
<p>pwm_L1.ChangeDutyCycle(0)</p>
<p>pwm_L2.ChangeDutyCycle(0)</p>
<p>pwm_R1.ChangeDutyCycle(0)</p>
<p>pwm_R2.ChangeDutyCycle(0)</p>
<p>while True:</p>
<p>dist = distance()</p>
<p>print("Measured Distance =  cm".format(dist))</p>
<p>#time.sleep(0.02)</p>
<p>if dist &lt; 10:</p>
<p>time.sleep(0.15)</p>
<p>car_back()</p>
<p>elif (dist&gt;=10 and dist&lt;=14):</p>
<p>car_stop()</p>
<p>time.sleep(0.1)</p>
<p>elif (dist&gt;14 and dist&lt;= 50):</p>
<p>time.sleep(0.15)</p>
<p>car_forward()</p>
<p>else:</p>
<p>car_stop()</p>
<p>print("stop")</p>
<p>#stop pwm</p>
<p>pwm_R1.stop()</p>
<p>pwm_L1.stop()</p>
<p>pwm_R2.stop()</p>
<p>pwm_L2.stop()</p>
<p>sleep(1)</p>
<p>GPIO.cleanup() #release all GPIO</p></td>
</tr>
</tbody>
</table>

 11.2 Run code and test result

cd /home/pi/RaspberryPi-Car/basic\_project

sudo python3 bp11\_follow\_car.py

Run test code and plug in power. Put your hand before the car, then it
will follow your hand to go forward, stop and go back.

### 12.Ultrasonic Obstacle Avoidance Robot 

Gauge distance by the ultrasonic detection to make car avoid the
obstacle.

**Principle：**

If the obstacle is away from more than 15cm, the car will go forward

If the obstacle is less than or equal to 15cm, the servo will rotate to
left and record the distance value away form an obstacle, then rotate to
right and record the distance value away from an obstacle. Next, compare
these two values, if left one is greater than the right one,the car will
turn left;otherwise, it will turn left.

**Logic Chart：**

<table>
<tbody>
<tr class="odd">
<td>Detected distance value</td>
<td>Left distance value</td>
<td>Right distance value</td>
<td>Compare values</td>
<td>Status</td>
</tr>
<tr class="even">
<td>&gt;15cm</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>Go forward</td>
</tr>
<tr class="odd">
<td>&lt;15cm</td>
<td>Servo rotates to 180°, the value is left_distance</td>
<td>Servo rotates to 0°, the value us right_distance</td>
<td><p>Servo rotates to 90°(front);</p>
<p>left_distance&gt;right_distance</p></td>
<td>Turn left</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td>left_distance&lt;right_distance</td>
<td>Turn right</td>
</tr>
</tbody>
</table>

 12.1 Code

<table>
<tbody>
<tr class="odd">
<td><p>import RPi.GPIO as GPIO</p>
<p>import time</p>
<p>GPIO.setwarnings(False)</p>
<p>GPIO.setmode(GPIO.BCM) # use BCM numbers</p>
<p>servoPin1 = 5</p>
<p>GPIO.setup(servoPin1, GPIO.OUT)</p>
<p>def servoPulse(servoPin, myangle):</p>
<p>pulsewidth = (myangle*11) + 500 # The pulse width</p>
<p>GPIO.output(servoPin,GPIO.HIGH)</p>
<p>time.sleep(pulsewidth/1000000.0)</p>
<p>GPIO.output(servoPin,GPIO.LOW)</p>
<p>time.sleep(20.0/1000 - pulsewidth/1000000.0) # The cycle of 20 ms</p>
<p>#define GPIO pin</p>
<p>GPIO_TRIGGER = 14</p>
<p>GPIO_ECHO = 4</p>
<p>#set GPIO mode (IN / OUT)</p>
<p>GPIO.setup(GPIO_TRIGGER, GPIO.OUT)</p>
<p>GPIO.setup(GPIO_ECHO, GPIO.IN)</p>
<p>def distance():</p>
<p># 10us is the trigger signal</p>
<p>GPIO.output(GPIO_TRIGGER, True)</p>
<p>time.sleep(0.00001) #10us</p>
<p>GPIO.output(GPIO_TRIGGER, False)</p>
<p>start_time = time.time() # Log the time the program runs to this point</p>
<p>stop_time = time.time() # Log the time the program runs to this point</p>
<p>while GPIO.input(GPIO_ECHO) == 0: #Indicates that the ultrasonic wave has been emitted</p>
<p>start_time = time.time() #Record launch time</p>
<p>while GPIO.input(GPIO_ECHO) == 1: #Indicates that the returned ultrasound has been received</p>
<p>stop_time = time.time() #Record receiving time</p>
<p>time_elapsed = stop_time - start_time #Time difference from transmit to receive</p>
<p>distance = (time_elapsed * 34000) / 2 #Calculate the distance</p>
<p>return distance #Return to calculated distance</p>
<p># Control M2 motor</p>
<p>L_IN1 = 20</p>
<p>L_IN2 = 21</p>
<p>L_PWM1 = 0</p>
<p># Control M1 motor</p>
<p>L_IN3 = 22</p>
<p>L_IN4 = 23</p>
<p>L_PWM2 = 1</p>
<p># Control M3 motor</p>
<p>R_IN1 = 24</p>
<p>R_IN2 = 25</p>
<p>R_PWM1 = 12</p>
<p># Control M4 motor</p>
<p>R_IN3 = 26</p>
<p>R_IN4 = 27</p>
<p>R_PWM2 = 13</p>
<p>#set the MOTOR Driver Pin OUTPUT mode</p>
<p>GPIO.setup(L_IN1,GPIO.OUT)</p>
<p>GPIO.setup(L_IN2,GPIO.OUT)</p>
<p>GPIO.setup(L_PWM1,GPIO.OUT)</p>
<p>GPIO.setup(L_IN3,GPIO.OUT)</p>
<p>GPIO.setup(L_IN4,GPIO.OUT)</p>
<p>GPIO.setup(L_PWM2,GPIO.OUT)</p>
<p>GPIO.setup(R_IN1,GPIO.OUT)</p>
<p>GPIO.setup(R_IN2,GPIO.OUT)</p>
<p>GPIO.setup(R_PWM1,GPIO.OUT)</p>
<p>GPIO.setup(R_IN3,GPIO.OUT)</p>
<p>GPIO.setup(R_IN4,GPIO.OUT)</p>
<p>GPIO.setup(R_PWM2,GPIO.OUT)</p>
<p>GPIO.output(L_IN1,GPIO.LOW)</p>
<p>GPIO.output(L_IN2,GPIO.LOW)</p>
<p>GPIO.output(L_IN3,GPIO.LOW)</p>
<p>GPIO.output(L_IN4,GPIO.LOW)</p>
<p>GPIO.output(R_IN1,GPIO.LOW)</p>
<p>GPIO.output(R_IN2,GPIO.LOW)</p>
<p>GPIO.output(R_IN3,GPIO.LOW)</p>
<p>GPIO.output(R_IN4,GPIO.LOW)</p>
<p>#set pwm frequence to 1000hz</p>
<p>pwm_R1 = GPIO.PWM(R_PWM1,100)</p>
<p>pwm_R2 = GPIO.PWM(R_PWM2,100)</p>
<p>pwm_L1 = GPIO.PWM(L_PWM1,100)</p>
<p>pwm_L2 = GPIO.PWM(L_PWM2,100)</p>
<p>#set inital duty cycle to 0</p>
<p>pwm_R1.start(0)</p>
<p>pwm_L1.start(0)</p>
<p>pwm_R2.start(0)</p>
<p>pwm_L2.start(0)</p>
<p># car forward</p>
<p>def car_forward():</p>
<p>GPIO.output(L_IN1,GPIO.LOW)</p>
<p>GPIO.output(L_IN2,GPIO.HIGH)</p>
<p>pwm_L1.ChangeDutyCycle(40)</p>
<p>GPIO.output(L_IN3,GPIO.HIGH)</p>
<p>GPIO.output(L_IN4,GPIO.LOW)</p>
<p>pwm_L2.ChangeDutyCycle(40)</p>
<p>GPIO.output(R_IN1,GPIO.HIGH)</p>
<p>GPIO.output(R_IN2,GPIO.LOW)</p>
<p>pwm_R1.ChangeDutyCycle(40)</p>
<p>GPIO.output(R_IN3,GPIO.LOW)</p>
<p>GPIO.output(R_IN4,GPIO.HIGH)</p>
<p>pwm_R2.ChangeDutyCycle(40)</p>
<p># car left</p>
<p>def car_left():</p>
<p>GPIO.output(L_IN1,GPIO.HIGH)</p>
<p>GPIO.output(L_IN2,GPIO.LOW)</p>
<p>pwm_L1.ChangeDutyCycle(80)</p>
<p>GPIO.output(L_IN3,GPIO.LOW)</p>
<p>GPIO.output(L_IN4,GPIO.HIGH)</p>
<p>pwm_L2.ChangeDutyCycle(80)</p>
<p>GPIO.output(R_IN1,GPIO.HIGH)</p>
<p>GPIO.output(R_IN2,GPIO.LOW)</p>
<p>pwm_R1.ChangeDutyCycle(80)</p>
<p>GPIO.output(R_IN3,GPIO.LOW)</p>
<p>GPIO.output(R_IN4,GPIO.HIGH)</p>
<p>pwm_R2.ChangeDutyCycle(80)</p>
<p># car right</p>
<p>def car_right():</p>
<p>GPIO.output(L_IN1,GPIO.LOW)</p>
<p>GPIO.output(L_IN2,GPIO.HIGH)</p>
<p>pwm_L1.ChangeDutyCycle(80)</p>
<p>GPIO.output(L_IN3,GPIO.HIGH)</p>
<p>GPIO.output(L_IN4,GPIO.LOW)</p>
<p>pwm_L2.ChangeDutyCycle(80)</p>
<p>GPIO.output(R_IN1,GPIO.LOW)</p>
<p>GPIO.output(R_IN2,GPIO.HIGH)</p>
<p>pwm_R1.ChangeDutyCycle(80)</p>
<p>GPIO.output(R_IN3,GPIO.HIGH)</p>
<p>GPIO.output(R_IN4,GPIO.LOW)</p>
<p>pwm_R2.ChangeDutyCycle(80)</p>
<p># car stop</p>
<p>def car_stop():</p>
<p>pwm_L1.ChangeDutyCycle(0)</p>
<p>pwm_L2.ChangeDutyCycle(0)</p>
<p>pwm_R1.ChangeDutyCycle(0)</p>
<p>pwm_R2.ChangeDutyCycle(0)</p>
<p># Loop several times to make sure the steering gear is turned to the specified Angle</p>
<p># The initialization Angle is 90 degrees</p>
<p>for g in range(0, 50):</p>
<p>servoPulse(servoPin1, 90)</p>
<p>while True:</p>
<p>dist = distance()</p>
<p>print("Measured Distance =  cm".format(dist))</p>
<p>time.sleep(0.01)</p>
<p>if dist &gt; 15: # If the obstacle in front is larger than 15cm</p>
<p>car_forward()</p>
<p>else: # If the obstacle in front is less than 15cm</p>
<p>dist = distance()</p>
<p>if dist &lt;= 15: # Make sure the obstacle in front is less than 15cm</p>
<p>car_stop()</p>
<p># Loop several times to make sure the steering gear is turned to the specified Angle</p>
<p>for i in range(0, 50):</p>
<p>servoPulse(servoPin1, 180)</p>
<p>time.sleep(0.1)</p>
<p>left_distance = distance() # Measure the distance to the left</p>
<p>time.sleep(0.2)</p>
<p>for j in range(0, 50):</p>
<p>servoPulse(servoPin1, 0)</p>
<p>time.sleep(0.1)</p>
<p>right_distance = distance() # Measure the distance to the right</p>
<p>time.sleep(0.2)</p>
<p>for k in range(0, 50):</p>
<p>servoPulse(servoPin1, 90)</p>
<p>time.sleep(0.3)</p>
<p># Compare the distance between the left and right sides</p>
<p>if left_distance &gt; right_distance:</p>
<p>car_left()</p>
<p>time.sleep(0.6)</p>
<p>#The car stops to prevent the sudden positive and</p>
<p>#negative rotation of the motor from causing the raspberry PI voltage and</p>
<p>#current too low malfunction</p>
<p>car_stop()</p>
<p>time.sleep(0.1)</p>
<p>else:</p>
<p>car_right()</p>
<p>time.sleep(0.6)</p>
<p>car_stop()</p>
<p>time.sleep(0.1)</p>
<p>#stop pwm</p>
<p>pwm_R1.stop()</p>
<p>pwm_L1.stop()</p>
<p>pwm_R2.stop()</p>
<p>pwm_L2.stop()</p>
<p>sleep(1)</p>
<p>GPIO.cleanup() #release all GPIO</p></td>
</tr>
</tbody>
</table>

 12.2 Run code and test result

cd /home/pi/RaspberryPi-Car/basic\_project

sudo python3 bp12\_avoid\_car.py

Run test code and plug in power. The car will avoid the obstacle


